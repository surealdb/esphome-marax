substitutions:
  esp_name: "MaraX"
  esp_hostname: "esphome-marax"

esphome:
  name: ${esp_hostname}
  friendly_name: "ESPHome MaraX"

esp32:
  board: esp32dev
  framework:
    type: arduino

# Enable logging
logger:

# Enable Home Assistant API
api:
  encryption:
    key: "dRo6fsq1XYVWKGGW8E0uVEHt6HXz4oaJfg8fZGfWlJI="

ota:


wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password

  # Enable fallback hotspot (captive portal) in case wifi connection fails
  ap:
    ssid: "Esphome-Web-29Dd60"
    password: "M8J5FyGyR9mz"

captive_portal:

sensor:
  - platform: template
    name: "Dampf Temp."
    id: "steam_actual"
    update_interval: 10s
    unit_of_measurement: "°C"
    device_class: "temperature"
    state_class: "measurement"
    accuracy_decimals: 1
  - platform: template
    name: "Dampf Zieltemp."
    id: "steam_target"
    update_interval: 10s
    unit_of_measurement: "°C"
    device_class: "temperature"
    state_class: "measurement"
    accuracy_decimals: 1
  - platform: template
    name: "HX Temp."
    id: "heat_actual"
    update_interval: 10s
    unit_of_measurement: "°C"
    device_class: "temperature"
    state_class: "measurement"
    accuracy_decimals: 1
  # countdown for 'boost-mode'
  - platform: template
    name: "Time Counter"
    id: "time_counter"
    update_interval: 5s
    unit_of_measurement: "s"
  # Uptime sensor.
  - platform: uptime
    name: ${esp_name} Uptime
    id: "uptime"
  # WiFi Signal sensor.
  - platform: wifi_signal
    name: ${esp_name} WiFi Signal
    update_interval: 60s
  - platform: template
    name: "Bezugsdauer"
    id: "timeElapsedSincePumpStarted"
    update_interval: 1s
    unit_of_measurement: "s"
    lambda: |-
      int timeElapsedSincePumpStarted = round(id(state_timeElapsedSincePumpStarted) / 1000);
      return timeElapsedSincePumpStarted;

binary_sensor:
  - platform: template
    name: "Heizt"
    id: "heating"
    # not allowed here
    # update_interval: 5s
  - platform: template
    name: "Pumpe an"
    id: "pumpActive"
    # not allowed here
    # update_interval: 5s
        
# Text sensors with general information.
text_sensor:
  # Expose ESPHome version as sensor.
  - platform: version
    name: "${esp_name} ESPHome Version"
  # Expose WiFi information as sensors.
  - platform: wifi_info
    ip_address:
      name: ${esp_name}
    ssid:
      name: ${esp_name}
    bssid:
      name: ${esp_name}
  - platform: template
    name: "Betriebsmodus"
    id: "opsType"
    filters:
      - map:
        - C -> Coffee Modus
        - S -> S Steam Modus
        - V -> V Steam Modus
        - X -> Offline
        - + -> MaraX Modus
    update_interval: 30s
  - platform: template
    name: "MaraX Firmware Version"
    id: "coffeeVersion"
    update_interval: 60s


# https://esphome.io/guides/automations.html#global-variables
globals:
  - id: state_previousTimestamp
    type: uint32_t
    restore_value: no
    initial_value: '0'
  - id: state_timeElapsedSincePumpStarted
    type: uint32_t
    restore_value: no
    initial_value: '0'


uart:
  baud_rate: 9600
  tx_pin: GPIO16
  rx_pin: GPIO17
  id: UART2
  debug:
    # https://community.home-assistant.io/t/how-to-uart-read-without-custom-component/491950 RX statt BOTH
    direction: BOTH
    dummy_receiver: true
    after:
      delimiter: "\r\n"
    sequence:
      - lambda: |-
          UARTDebug::log_string(direction, bytes);
          
          bool debugMode = true;
    
          char senType[1];
          char senVersion[4];
          int senSteamActual=0;
          int senSteamTarget=0;
          char senSteamTargetStr[3];
          int senHeatActual=0;
          int senCounter=0;
          int senHeating=0;
          int senPumpActive=0;
          
          uint32_t previousTimestamp=0;
          uint32_t currentTimestamp=0;
          uint32_t timeElapsed=0;
          int lastPumpActiveState=0;
          
          char buff[10];
          std::string buffAsStdStr;
          
          std::string str(bytes.begin(), bytes.end()); //TODO
          
          int elementCount = sscanf(str.c_str(), "%1c%4c,%d,%d,%d,%d,%d,%d", senType, senVersion, &senSteamActual, &senSteamTarget, &senHeatActual, &senCounter, &senHeating, &senPumpActive);
          
          if(debugMode) printf("Element Count: %d \n", elementCount);
          
          if(elementCount == 3) {
              if(debugMode) {
                  printf("Wasserbehaelter entfernt\n");
                  ESP_LOGD("MaraX", "Wasserbehaelter entfernt\n");
              }
              
              elementCount = sscanf(str.c_str(), "%1c%4c,%d,%3c,%d,%d,%d,%d", senType, senVersion, &senSteamActual, senSteamTargetStr, &senHeatActual, &senCounter, &senHeating, &senPumpActive);
          }
          
          if (elementCount >= 7 ) {
              
              snprintf(buff, sizeof(buff), "%.1s", senType);
              buffAsStdStr = buff;
              if(debugMode) {
                  printf("Ops Mode: %s \n", buffAsStdStr.c_str());
                  ESP_LOGD("MaraX", "Ops Mode: %s \n", buffAsStdStr.c_str());
              }
              id(opsType).publish_state(buffAsStdStr.c_str());
              
              snprintf(buff, sizeof(buff), "%.4s", senVersion);
              buffAsStdStr = buff;
              if(debugMode) {
                  printf("MaraX Firmware: %s \n", buffAsStdStr.c_str());
                  ESP_LOGD("MaraX", "MaraX Firmware: %s \n", buffAsStdStr.c_str());
              }
              id(coffeeVersion).publish_state(buffAsStdStr.c_str());
              
              if(debugMode) {
                  printf("Steam Actual: %d \n", senSteamActual);
                  //ESP_LOGD("MaraX", "Steam Actual: %d \n", senSteamActual);
              }
              id(steam_actual).publish_state(senSteamActual);
              
              if(debugMode) {
                  printf("Steam Target: %d \n", senSteamTarget);
                  ESP_LOGD("MaraX", "Steam Target: %d \n", senSteamTarget);
              }
              id(steam_target).publish_state(senSteamTarget);
              
              if(debugMode) {
                  printf("Heat Actual: %d \n", senHeatActual);
                  ESP_LOGD("MaraX", "Heat Actual: %d \n", senHeatActual);
              }
              id(heat_actual).publish_state(senHeatActual);
              
              if(debugMode) {
                  printf("Time Counter: %d \n", senCounter);
                  ESP_LOGD("MaraX", "Time Counter: %d \n", senCounter);
              }
              id(time_counter).publish_state(senCounter);
              
              if(debugMode) {
                  printf("Is Heating: %d \n", senHeating);
                  ESP_LOGD("MaraX", "Is Heating: %d \n", senHeating);
              }
              id(heating).publish_state(senHeating);
              
              if(debugMode) {
                  printf("Pumpe an: %d \n", senPumpActive);
                  ESP_LOGD("MaraX", "Pumpe an: %d \n", senPumpActive);
              }
              
              currentTimestamp = millis(); // TODO
              //currentTimestamp = getCurrentTimestamp(); // TODO remove
              
              previousTimestamp = id(state_previousTimestamp); // TODO
              //previousTimestamp = state_previousTimestamp; // TODO remove
              // init previous timestamp if needed
              if (previousTimestamp == 0) {
                  previousTimestamp = currentTimestamp;
              }
              
              if(senPumpActive == 1 && currentTimestamp != 0) {
                  
                  lastPumpActiveState = round(id(pumpActive).raw_state); // TODO
                  //lastPumpActiveState = pumpActive; // TODO remove
                  
                  timeElapsed = id(state_timeElapsedSincePumpStarted); // TODO
                  //timeElapsed = state_timeElapsedSincePumpStarted; // TODO remove
                  // if pump just started
                  if (lastPumpActiveState == 0) {
                      // reset time elapsed counter
                      timeElapsed = 0;
                  }
                  timeElapsed = timeElapsed + (currentTimestamp - previousTimestamp);
                  
                  id(state_timeElapsedSincePumpStarted) = timeElapsed; // TODO
                  //state_timeElapsedSincePumpStarted = timeElapsed; // TODO remove
              }
              
              id(state_previousTimestamp) = currentTimestamp; // TODO
              //state_previousTimestamp = currentTimestamp; // TODO remove
              
              id(pumpActive).publish_state(senPumpActive);
              //pumpActive = senPumpActive; // TODO remove
          }